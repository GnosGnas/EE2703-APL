'''
Title    : Assignment-4
Purpose  : To compute Fourier Series' coefficients using different methods and to compare and contrast each of them
Author   : Surya Prasad.S(EE19B121) 
Date     : 10th March 2021
Outputs  : Various plots to compare and contrast the Fourier Series coefficients got through integration and Least Squares approach
'''


# Importing libraries
import numpy as np
import scipy
import scipy.integrate as integrate
import matplotlib.pyplot as plt
import math


# Constants used in this code
PI = np.pi                      # Ï€ value
N = 100000                      # Number of elements in a vector which is going to be plotted
THRESHOLD = float('1e-12')      # Used to control the error due to integration


# Function to calculate exp(x)
def e(x):
    return np.exp(x)

# Function to calculate cos(cos(x))
def cos_cos(x):
    return np.cos(np.cos(x))

# Function which returns the periodic form of any given function
def periodic(func, x, lower_limit = 0, upper_limit = 2 * PI):
    return func(np.remainder(x - lower_limit, upper_limit - lower_limit))


# Q1: To plot the two functions over the interval [-2*PI,4*PI) and also plot the expected function generated by the Fourier Series
x = np.linspace(-2*PI, 4*PI, N)
x = np.reshape(x, (N, 1))

## Plotting exp(x) in semilogy plot
print("Plotting exp(x) in semilogy scale")
plt.figure(1)
plt.title(r'Q1: $e^x$ in semilogy scale')
plt.xlabel('x')
plt.ylabel(r'$log_{10}(e^x)$')
plt.grid(True)
plt.semilogy(x, e(x))
plt.show()

## Plotting cos(cos(x))
print("Plotting cos(cos(x))")
plt.figure(2)
plt.title(r'Q1: Plot of $cos(cos(x))$')
plt.xlabel('x')
plt.ylabel(r'$cos(cos(x))$')
plt.grid(True)
plt.plot(x, cos_cos(x))
plt.show()


y_1 = e(x)                  # Vector of exponent values
y_2 = periodic(e, x)        # Vector of expected values

## Plotting the expected plot generated by Fourier Series and the actual plot
print("Plotting the expected Fourier Series generated exponent")
plt.figure(1)
plt.title(r'Q1: Expected $e^x$ generated by Fourier Series vs actual plot of function')
plt.xlabel('x')
plt.ylabel(r'$log_{10}(e^x)$')
plt.grid(True)
plt.semilogy(x, y_1)
plt.semilogy(x, y_2)
plt.legend([r'$e^x$', "Ideal Fourier Series plot"])
plt.show()


y_1 = cos_cos(x)            # Vector of cos(cos(x)) 
y_2 = periodic(cos_cos, x)  # Vector of expected values

print("Plotting the expected Fourier Series generated cos(cos(x)) vs actual plot of cos(cos(x))")
plt.figure(2)
plt.title(r'Q1: Plot of $cos(cos(x))$ vs actual plot of function')
plt.xlabel('x')
plt.ylabel(r'$cos(cos(x))$')
plt.grid(True)
plt.plot(x, y_1, linewidth = 3)
plt.plot(x, y_2)
plt.legend([r'$cos(cos(x))$', "Ideal Fourier Series plot"])
plt.show()


# Q2: Now, to compute the 51 coefficients for the two functions using the built in integrator in Python

## First, we shall define the function to calculate the Fourier Series
## Here we are storing the values in the vector in the form (a0, a1, b1, a2, b2, ...)
def Fourier_Series_Coefficients(n, func, lower_limit = 0, upper_limit = 2 * PI):
    Coefficients = np.zeros(n)

    def fcos(x, n, f):
        return f(x) * np.cos(n*x) * (1/PI)

    def fsin(x, n, f):
        return f(x) * np.sin(n*x) * (1/PI)

    Coefficients[0] = integrate.quad(func, lower_limit, upper_limit, epsabs = THRESHOLD)[0] * (1/(2 * PI))

    for i in range(1, n):
        if i%2 == 1:
            Coefficients[i] = integrate.quad(fcos, lower_limit, upper_limit, args = ((i//2 + 1), func), epsabs = THRESHOLD)[0]

        else:
            Coefficients[i] = integrate.quad(fsin, lower_limit, upper_limit, args = (i//2, func), epsabs = THRESHOLD)[0]

    return Coefficients

## Fourier Series Coefficients are calculated and stored
e_FS = Fourier_Series_Coefficients(51, e) 
cos_cos_FS = Fourier_Series_Coefficients(51, cos_cos)


# Q3: To plot the coefficients

## Plot of Fourier Series coefficients of exp(x) in semilog and loglog plots
print("Plotting Fourier Series coefficients of exp(x) in semilogy and loglog scale")
plt.figure(3)
plt.title(r"Q3: Coefficients of Fourier Series of $e^x$ in semilogy scale")
plt.xlabel(r'$nth$ coefficient')
plt.ylabel(r'$log_{10}(coeff)$')
plt.semilogy(abs(e_FS), 'ro')
plt.grid(True)
plt.show()

plt.figure(4)
plt.title(r"Q3: Coefficients of Fourier Series of $e^x$ in loglog scale")
plt.xlabel(r'$log_{10}(n)$')
plt.ylabel(r'$log_{10}(coeff)$')
plt.loglog(abs(e_FS), 'ro')
plt.grid(True)
plt.show()


## Plot of Fourier Series coefficients of cos(cos(x)) on semilog and loglog plots
print("Plotting Fourier Series coefficients of cos(cos(x)) on semilogy and loglog")
plt.figure(5)
plt.title(r"Q3: Coefficients of Fourier Series of $cos(cos(x))$ in semilogy scale")
plt.xlabel(r'$nth$ coefficient')
plt.ylabel(r'$log_{10}(coeff)$')
plt.semilogy(abs(cos_cos_FS), 'ro')
plt.grid(True)
plt.show()

plt.figure(6)
plt.title(r"Q3: Coefficients of Fourier Series of $cos(cos(x))$ in loglog scale")
plt.xlabel(r'$log_{10}(n)$')
plt.ylabel(r'$log_{10}(coeff)$')
plt.loglog(abs(cos_cos_FS), 'ro')
plt.grid(True)
plt.show()


## Plotting functions generated using Fourier Series
### First, we shall define a function to compute the values
def Fourier_Series_Values(x, FS_coeff):
    n = np.size(FS_coeff,0)

    result = np.zeros((np.size(x, 0), 1))
    result += FS_coeff[0]

    for i in range(n):
        if i%2 == 0:
            result += FS_coeff[i] * np.sin(i//2 * x);

        else:
            result += FS_coeff[i] * np.cos((i//2 + 1) * x);

    return result

y_1 = periodic(e, x)                        # Vector of expected values
y_2 = Fourier_Series_Values(x, e_FS)        # Vector of generated values

### Now we plot the function generated by Fourier Series and the actual plot
print("Plotting Fourier Series generated exponent vs an ideal plot")
plt.figure(1)
plt.title(r'Q3: $e^x$ generated by Fourier Series vs ideal plot of the function')
plt.xlabel('x')
plt.ylabel(r'$log_{10}(e^x)$')
plt.grid(True)
plt.semilogy(x, y_1)
plt.semilogy(x, y_2)
plt.legend(["Ideal Fourier Series plot", r'Generated $e^x$'])
plt.show()

y_1 = cos_cos(x)                            # Vector of cos(cos(x)) 
y_2 = Fourier_Series_Values(x, cos_cos_FS)  # Vector of generated values

print("Plotting Fourier Series generated cos(cos(x)) vs plot of cos(cos(x))")
plt.figure(2)
plt.title(r'Q3: $cos(cos(x))$ generated by Fourier Series vs ideal plot of the function')
plt.xlabel('x')
plt.ylabel(r'$cos(cos(x))$')
plt.grid(True)
plt.semilogy(x, y_1, linewidth = 3)
plt.semilogy(x, y_2)
plt.legend(["Ideal Fourier Series plot", r'Generated $cos(cos(x))$'])
plt.show() 


# Q4: To find the coefficients using "Least Squares approach"

## First, we shall define a function to compute and then store the computed values
def Least_Square_Fitting(func):
    x = np.linspace(0, 2 * PI, 401)
    x = x[:-1]

    A = np.zeros((x.shape[0], 51))
    A[:, 0] = 1

    for i in range(1, 26):
        A[:, 2 * i - 1] = np.cos(i * x)
        A[:, 2 * i] = np.sin(i * x)

    B = func(x)

    best_fit = scipy.linalg.lstsq(A, B)[0]

    return best_fit, A

e_LS_coeff, e_LS_A = Least_Square_Fitting(e)
cos_cos_LS_coeff, cos_cos_LS_A = Least_Square_Fitting(cos_cos)


# Q5: To plot Fourier Series coefficients computed using Least Square approach

print("Plotting of Fourier Series coefficients generated using Least Square approach")
plt.figure(1)
plt.title(r"Q5: Coefficients of Fourier Series of $e^x$ using Least Square approach in semilogy scale")
plt.xlabel(r'$nth$ coefficient')
plt.ylabel(r'$log_{10}(coeff)$')
plt.semilogy(abs(e_LS_coeff), 'go')
plt.semilogy(abs(e_FS), 'ro', markersize = 4)
plt.legend(['Least Square\'s coeff', 'Fourier Series coeff'])
plt.grid(True)
plt.show()

plt.figure(2)
plt.title(r"Q5: Coefficients of Fourier Series of $e^x$ using Least Square approach in loglog scale")
plt.xlabel(r'$log_{10}(n)$')
plt.ylabel(r'$log_{10}(coeff)$')
plt.loglog(abs(e_LS_coeff), 'go')
plt.loglog(abs(e_FS), 'ro', markersize = 4)
plt.legend(['Least Square\'s coeff', 'Fourier Series coeff'])
plt.grid(True)
plt.show()

plt.figure(3)
plt.title(r"Q5: Coefficients of Fourier Series of $cos(cos(x))$ using Least Square approach in semilogy scale")
plt.xlabel(r'$nth$ coefficient')
plt.ylabel(r'$log_{10}(coeff)$')
plt.semilogy(abs(cos_cos_LS_coeff), 'go')
plt.semilogy(abs(cos_cos_FS), 'ro', markersize = 4)
plt.legend(['Least Square\'s coeff', 'Fourier Series coeff'])
plt.grid(True)
plt.show()

plt.figure(4)
plt.title(r"Q5: Coefficients of Fourier Series of $cos(cos(x))$ using Least Square approach in loglog scale")
plt.xlabel(r'$log_{10}(n)$')
plt.ylabel(r'$log_{10}(coeff)$')
plt.loglog(abs(cos_cos_LS_coeff), 'go')
plt.loglog(abs(cos_cos_FS), 'ro', markersize = 4)
plt.legend(['Least Square\'s coeff', 'Fourier Series coeff'])
plt.grid(True)
plt.show()


# Q6: To find the maximum deviation of the computed coefficients
Error_e = np.amax(np.abs(e_FS - e_LS_coeff))
Error_cos_cos = np.amax(np.abs(cos_cos_FS - cos_cos_LS_coeff))

print("The maximum deviation in Least Square coefficients of exp(x) compared to True values is", Error_e)
print("The maximum deviation in Least Square coefficients of cos(cos(x)) compared to True values is", Error_cos_cos)


# Q7: To compute A*c from the estimated values of c and plot them

## Computing A*c
e_LS_B = np.dot(e_LS_A, e_LS_coeff)
cos_cos_LS_B = np.dot(cos_cos_LS_A, cos_cos_LS_coeff)
x = np.linspace(0, 2 * PI, 401)
x = x[:-1]

## Plotting Least square generated values against expected values
y = periodic(e, x)                                    # Vector of expected values

print("Plotting the expected values against Least Square generated values")
plt.figure(1)
plt.title(r'Q7: Expected $e^x$ generated using Least Square vs actual plot of function')
plt.xlabel('x')
plt.ylabel(r'$log_{10}(e^x)$')
plt.grid(True)
plt.semilogy(x, y)
plt.semilogy(x, e_LS_B, 'go', markersize = 4)
plt.legend(['Ideal Fourier Series plot', 'Generated plot using Least Squares'])
plt.show()

y = periodic(cos_cos, x)                            # Vector of expected values

plt.figure(2)
plt.title(r'Q7: Expected $cos(cos(x))$ generated using Least Square vs actual plot of function')
plt.xlabel('x')
plt.ylabel(r'$cos(cos(x))$')
plt.grid(True)
plt.plot(x, y)
plt.plot(x, cos_cos_LS_B, 'go', markersize = 4)
plt.legend(['Ideal Fourier Series plot', 'Generated plot using Least Squares'])
plt.show()
